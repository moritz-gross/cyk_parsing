from __future__ import annotations

from collections import defaultdict
from typing import Iterable


def cyk_accepts(
    input_data: Iterable[str] | str,
    grammar: dict[str, list[tuple[str, str] | str]],
    start_symbol: str = "S",
) -> bool:
    """
    Determine whether input_data is generated by a CNF grammar using CYK.

    input_data can be an iterable of tokens or a string (treated as characters).
    Grammar format: {NonTerminal: [("A", "B"), "a", ...]}.
    Use "" for an epsilon production (only supported for empty input).
    """
    tokens = list(input_data) if not isinstance(input_data, str) else list(input_data)

    term_map: dict[str, set[str]] = defaultdict(set)
    pair_map: dict[tuple[str, str], set[str]] = defaultdict(set)
    epsilon_set: set[str] = set()

    for lhs, productions in grammar.items():
        for prod in productions:
            if isinstance(prod, str):
                if prod == "":
                    epsilon_set.add(lhs)
                else:
                    term_map[prod].add(lhs)
            else:
                if len(prod) != 2:
                    raise ValueError(f"Non-terminal production must be length 2: {lhs} -> {prod}")
                pair_map[(prod[0], prod[1])].add(lhs)

    n = len(tokens)
    if n == 0:
        return start_symbol in epsilon_set

    table: list[list[set[str]]] = [[set() for _ in range(n)] for _ in range(n)]

    for i, token in enumerate(tokens):
        table[i][i].update(term_map.get(token, set()))

    for span in range(2, n + 1):
        for i in range(n - span + 1):
            j = i + span - 1
            cell = table[i][j]
            for k in range(i, j):
                left = table[i][k]
                right = table[k + 1][j]
                for b in left:
                    for c in right:
                        cell.update(pair_map.get((b, c), set()))

    return start_symbol in table[0][n - 1]
